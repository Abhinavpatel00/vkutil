<svg viewBox="0 0 1600 2000" xmlns="http://www.w3.org/2000/svg">
  <!-- Title -->
  <text x="800" y="40" font-size="28" font-weight="bold" text-anchor="middle" fill="#2c3e50">
    Bindless + Multi-Draw Indirect
  </text>
  <text x="800" y="70" font-size="15" text-anchor="middle" fill="#7f8c8d">
    GPU-Driven Rendering with Minimal CPU Overhead
  </text>
  
  <!-- ===== TRADITIONAL CPU-DRIVEN ===== -->
  <rect x="50" y="100" width="720" height="450" fill="#ffe8e8" stroke="#e74c3c" stroke-width="3" rx="10"/>
  <text x="410" y="135" font-size="20" font-weight="bold" text-anchor="middle" fill="#c0392b">
    ‚ùå Traditional CPU-Driven (Without Multi-Draw)
  </text>
  
  <!-- CPU side -->
  <g transform="translate(80, 160)">
    <rect x="0" y="0" width="660" height="200" fill="#fff" stroke="#e74c3c" stroke-width="2" rx="6"/>
    <text x="330" y="30" font-size="16" font-weight="bold" text-anchor="middle" fill="#c0392b">
      CPU Processing (Heavy Load)
    </text>
    
    <rect x="20" y="50" width="620" height="130" fill="#ecf0f1" stroke="#95a5a6" stroke-width="1" rx="4"/>
    <text x="30" y="75" font-size="12" font-family="monospace" fill="#2c3e50">for (int i = 0; i &lt; numObjects; i++) {</text>
    <text x="50" y="95" font-size="12" font-family="monospace" fill="#e74c3c">  if (objects[i].visible) {  // CPU culling</text>
    <text x="70" y="115" font-size="12" font-family="monospace" fill="#2c3e50">    if (pipelineChanged) vkCmdBindPipeline(...);</text>
    <text x="70" y="135" font-size="12" font-family="monospace" fill="#2c3e50">    vkCmdPushConstants(..., drawDataIndex);</text>
    <text x="70" y="155" font-size="12" font-family="monospace" fill="#2c3e50">    vkCmdDrawIndexed(...);</text>
    <text x="50" y="175" font-size="12" font-family="monospace" fill="#2c3e50">  }</text>
    <text x="30" y="195" font-size="12" font-family="monospace" fill="#2c3e50">}</text>
  </g>
  
  <!-- Issues list -->
  <g transform="translate(100, 380)">
    <text x="0" y="0" font-size="14" font-weight="bold" fill="#e74c3c">Problems:</text>
    <text x="20" y="25" font-size="12" fill="#2c3e50">‚Ä¢ CPU does visibility/culling (slow for large scenes)</text>
    <text x="20" y="45" font-size="12" fill="#2c3e50">‚Ä¢ One vkCmd call per visible object (API overhead)</text>
    <text x="20" y="65" font-size="12" fill="#2c3e50">‚Ä¢ CPU-GPU synchronization bottleneck</text>
    <text x="20" y="85" font-size="12" fill="#2c3e50">‚Ä¢ Cannot easily leverage GPU compute for culling</text>
    <text x="20" y="105" font-size="12" fill="#2c3e50">‚Ä¢ Pipeline changes require sorting on CPU</text>
  </g>
  
  <!-- ===== GPU-DRIVEN WITH MULTIDRAW ===== -->
  <rect x="50" y="580" width="1500" height="1350" fill="#e8f8f0" stroke="#27ae60" stroke-width="3" rx="10"/>
  <text x="800" y="615" font-size="20" font-weight="bold" text-anchor="middle" fill="#229954">
    ‚úÖ GPU-Driven with Multi-Draw Indirect + Bindless
  </text>
  <text x="800" y="640" font-size="13" text-anchor="middle" fill="#7f8c8d">
    GPU does culling, CPU just submits one command
  </text>
  
  <!-- Step 1: CPU Preparation -->
  <g transform="translate(80, 670)">
    <rect x="0" y="0" width="700" height="200" fill="#3498db" stroke="#2980b9" stroke-width="2" rx="6"/>
    <text x="350" y="30" font-size="16" font-weight="bold" text-anchor="middle" fill="#fff">
      Step 1: CPU Preparation (Once per Frame)
    </text>
    
    <rect x="20" y="50" width="660" height="130" fill="#fff" stroke="#2980b9" stroke-width="1" rx="4"/>
    <text x="30" y="75" font-size="11" fill="#2c3e50">1. Update global descriptor set (materials, transforms, draw data)</text>
    <text x="30" y="95" font-size="11" fill="#2c3e50">2. Bind Set 0 (global descriptors) - ONCE</text>
    <text x="30" y="115" font-size="11" fill="#2c3e50">3. Bind index buffer - ONCE</text>
    <text x="30" y="135" font-size="11" fill="#2c3e50">4. Upload object bounding boxes/data to GPU buffer</text>
    <text x="30" y="155" font-size="11" fill="#2c3e50">5. Dispatch compute shader for GPU culling</text>
  </g>
  
  <!-- Step 2: GPU Culling -->
  <g transform="translate(820, 670)">
    <rect x="0" y="0" width="660" height="200" fill="#9b59b6" stroke="#8e44ad" stroke-width="2" rx="6"/>
    <text x="330" y="30" font-size="16" font-weight="bold" text-anchor="middle" fill="#fff">
      Step 2: GPU Compute Culling
    </text>
    
    <rect x="20" y="50" width="620" height="130" fill="#fff" stroke="#8e44ad" stroke-width="1" rx="4"/>
    <text x="30" y="75" font-size="11" font-family="monospace" fill="#2c3e50">// Compute shader (parallel)</text>
    <text x="30" y="95" font-size="11" font-family="monospace" fill="#2c3e50">if (frustumCull(object.bounds)) {</text>
    <text x="50" y="115" font-size="11" font-family="monospace" fill="#27ae60">  uint idx = atomicAdd(drawCount, 1);</text>
    <text x="50" y="135" font-size="11" font-family="monospace" fill="#27ae60">  drawCommands[idx] = createDrawCmd(object);</text>
    <text x="30" y="155" font-size="11" font-family="monospace" fill="#2c3e50">}</text>
    
    <text x="330" y="190" font-size="10" font-style="italic" text-anchor="middle" fill="#7f8c8d">
      GPU culls and builds draw commands in parallel
    </text>
  </g>
  
  <!-- Draw Command Buffer Structure -->
  <g transform="translate(80, 900)">
    <rect x="0" y="0" width="1400" height="240" fill="#fff" stroke="#f39c12" stroke-width="2" rx="6"/>
    <text x="700" y="30" font-size="16" font-weight="bold" text-anchor="middle" fill="#d68910">
      Draw Command Buffer (VkDrawIndexedIndirectCommand)
    </text>
    <text x="700" y="50" font-size="12" text-anchor="middle" fill="#7f8c8d">
      GPU writes this, GPU reads this - CPU never touches it
    </text>
    
    <!-- Command structure -->
    <g transform="translate(50, 70)">
      <rect x="0" y="0" width="1300" height="140" fill="#fef5e7" stroke="#f39c12" stroke-width="1" rx="4"/>
      
      <text x="10" y="25" font-size="11" font-weight="bold" fill="#d68910">struct VkDrawIndexedIndirectCommand {</text>
      
      <rect x="40" y="35" width="200" height="30" fill="#3498db" stroke="#2980b9" stroke-width="1" rx="3"/>
      <text x="140" y="55" font-size="10" text-anchor="middle" fill="#fff">uint32_t indexCount;</text>
      
      <rect x="260" y="35" width="200" height="30" fill="#3498db" stroke="#2980b9" stroke-width="1" rx="3"/>
      <text x="360" y="55" font-size="10" text-anchor="middle" fill="#fff">uint32_t instanceCount;</text>
      
      <rect x="480" y="35" width="200" height="30" fill="#3498db" stroke="#2980b9" stroke-width="1" rx="3"/>
      <text x="580" y="55" font-size="10" text-anchor="middle" fill="#fff">uint32_t firstIndex;</text>
      
      <rect x="700" y="35" width="200" height="30" fill="#3498db" stroke="#2980b9" stroke-width="1" rx="3"/>
      <text x="800" y="55" font-size="10" text-anchor="middle" fill="#fff">int32_t vertexOffset;</text>
      
      <rect x="920" y="35" width="200" height="30" fill="#e74c3c" stroke="#c0392b" stroke-width="1" rx="3"/>
      <text x="1020" y="55" font-size="10" text-anchor="middle" fill="#fff">uint32_t firstInstance;</text>
      
      <text x="10" y="85" font-size="11" font-weight="bold" fill="#d68910">};</text>
      
      <text x="650" y="115" font-size="11" font-style="italic" text-anchor="middle" fill="#e74c3c">
        ‚Üê Use this as drawDataIndex! (via gl_InstanceIndex or gl_DrawID)
      </text>
      <path d="M 1020 65 L 1020 100" stroke="#e74c3c" stroke-width="2" marker-end="url(#arrow-down)"/>
    </g>
    
    <text x="50" y="230" font-size="10" fill="#7f8c8d">
      Array of these commands in GPU buffer. Each command = one draw call executed by GPU.
    </text>
  </g>
  
  <!-- Step 3: Multi-Draw Indirect -->
  <g transform="translate(80, 1170)">
    <rect x="0" y="0" width="1400" height="280" fill="#27ae60" stroke="#229954" stroke-width="2" rx="6"/>
    <text x="700" y="35" font-size="16" font-weight="bold" text-anchor="middle" fill="#fff">
      Step 3: Multi-Draw Indirect Execution
    </text>
    
    <!-- CPU command -->
    <rect x="50" y="60" width="600" height="90" fill="#fff" stroke="#229954" stroke-width="2" rx="4"/>
    <text x="350" y="85" font-size="13" font-weight="bold" text-anchor="middle" fill="#27ae60">
      CPU (Single Command!)
    </text>
    <text x="60" y="110" font-size="11" font-family="monospace" fill="#2c3e50">vkCmdBindPipeline(cmd, pipeline);</text>
    <text x="60" y="130" font-size="11" font-family="monospace" fill="#2c3e50">vkCmdDrawIndexedIndirectCount(cmd, drawBuffer,</text>
    <text x="60" y="150" font-size="11" font-family="monospace" fill="#2c3e50">    offset, countBuffer, countOffset, maxDraws);</text>
    
    <!-- GPU execution -->
    <rect x="700" y="60" width="650" height="190" fill="#fff" stroke="#229954" stroke-width="2" rx="4"/>
    <text x="1025" y="85" font-size="13" font-weight="bold" text-anchor="middle" fill="#27ae60">
      GPU (Executes All Draws)
    </text>
    <text x="710" y="110" font-size="11" font-family="monospace" fill="#2c3e50">// GPU reads drawCount from countBuffer</text>
    <text x="710" y="130" font-size="11" font-family="monospace" fill="#2c3e50">for (uint i = 0; i &lt; drawCount; i++) {</text>
    <text x="730" y="150" font-size="11" font-family="monospace" fill="#27ae60">  VkDrawCmd cmd = drawBuffer[i];</text>
    <text x="730" y="170" font-size="11" font-family="monospace" fill="#27ae60">  executeDrawIndexed(cmd);  // Hardware</text>
    <text x="730" y="190" font-size="11" font-family="monospace" fill="#7f8c8d">  // gl_DrawID = i (shader uses as index)</text>
    <text x="710" y="210" font-size="11" font-family="monospace" fill="#2c3e50">}</text>
    
    <text x="1025" y="240" font-size="10" font-style="italic" text-anchor="middle" fill="#7f8c8d">
      All draws execute in parallel on GPU - no CPU loop!
    </text>
  </g>
  
  <!-- Step 4: Shader Execution -->
  <g transform="translate(80, 1480)">
    <rect x="0" y="0" width="1400" height="210" fill="#34495e" stroke="#2c3e50" stroke-width="2" rx="6"/>
    <text x="700" y="35" font-size="16" font-weight="bold" text-anchor="middle" fill="#ecf0f1">
      Step 4: Shader Execution (Uses gl_DrawID)
    </text>
    
    <!-- Vertex shader -->
    <rect x="50" y="60" width="650" height="130" fill="#2c3e50" stroke="#34495e" stroke-width="1" rx="4"/>
    <text x="375" y="85" font-size="13" font-weight="bold" text-anchor="middle" fill="#52c9a5">
      Vertex Shader
    </text>
    <text x="60" y="110" font-size="10" font-family="monospace" fill="#52c9a5">#extension GL_ARB_shader_draw_parameters : require</text>
    <text x="60" y="128" font-size="10" font-family="monospace" fill="#fff">DrawData dd = drawData[gl_DrawIDARB];</text>
    <text x="60" y="146" font-size="10" font-family="monospace" fill="#fff">TransformData td = transforms[dd.transformOffset];</text>
    <text x="60" y="164" font-size="10" font-family="monospace" fill="#fff">vec4 pos = vertexData[gl_VertexIndex + dd.vertexOffset];</text>
    <text x="60" y="182" font-size="10" font-family="monospace" fill="#fff">gl_Position = projection * view * td.transform * pos;</text>
    
    <!-- Fragment shader -->
    <rect x="750" y="60" width="600" height="130" fill="#2c3e50" stroke="#34495e" stroke-width="1" rx="4"/>
    <text x="1050" y="85" font-size="13" font-weight="bold" text-anchor="middle" fill="#52c9a5">
      Fragment Shader
    </text>
    <text x="760" y="110" font-size="10" font-family="monospace" fill="#fff">DrawData dd = drawData[gl_DrawIDARB];</text>
    <text x="760" y="128" font-size="10" font-family="monospace" fill="#fff">MaterialData md = materials[dd.materialIndex];</text>
    <text x="760" y="146" font-size="10" font-family="monospace" fill="#fff">vec4 albedo = texture(sampler2D(</text>
    <text x="760" y="164" font-size="10" font-family="monospace" fill="#fff">  materialTextures[md.albedoTexture],</text>
    <text x="760" y="182" font-size="10" font-family="monospace" fill="#fff">  albedoSampler), uv);</text>
  </g>
  
  <!-- Pipeline bucketing note -->
  <g transform="translate(80, 1720)">
    <rect x="0" y="0" width="1400" height="110" fill="#fff9e6" stroke="#f39c12" stroke-width="2" rx="6"/>
    <text x="700" y="30" font-size="15" font-weight="bold" text-anchor="middle" fill="#d68910">
      ‚ö†Ô∏è Important: Pipeline Bucketing
    </text>
    <text x="30" y="60" font-size="12" fill="#2c3e50">
      ‚Ä¢ Multi-draw indirect can only use ONE pipeline per command
    </text>
    <text x="30" y="80" font-size="12" fill="#2c3e50">
      ‚Ä¢ CPU must bucket draws by pipeline/shader before GPU culling
    </text>
    <text x="30" y="100" font-size="12" fill="#2c3e50">
      ‚Ä¢ Solution: Issue multiple vkCmdDrawIndexedIndirectCount calls (one per pipeline bucket)
    </text>
  </g>
  
  <!-- Benefits comparison -->
  <g transform="translate(80, 1860)">
    <rect x="0" y="0" width="1400" height="100" fill="#e8f8e8" stroke="#27ae60" stroke-width="2" rx="6"/>
    <text x="700" y="30" font-size="16" font-weight="bold" text-anchor="middle" fill="#229954">
      üöÄ Performance Benefits
    </text>
    
    <g transform="translate(50, 45)">
      <text x="0" y="0" font-size="12" fill="#2c3e50">
        ‚úì CPU overhead: O(1) instead of O(N) draw calls
      </text>
      <text x="450" y="0" font-size="12" fill="#2c3e50">
        ‚úì GPU culling happens in parallel
      </text>
      <text x="900" y="0" font-size="12" fill="#2c3e50">
        ‚úì No CPU-GPU sync for visibility
      </text>
      <text x="0" y="22" font-size="12" fill="#2c3e50">
        ‚úì Scales to millions of objects
      </text>
      <text x="450" y="22" font-size="12" fill="#2c3e50">
        ‚úì Efficient occlusion culling on GPU
      </text>
      <text x="900" y="22" font-size="12" fill="#2c3e50">
        ‚úì Perfect for open world games
      </text>
    </g>
  </g>
  
  <!-- Arrow marker -->
  <defs>
    <marker id="arrow-down" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
      <path d="M0,0 L10,5 L0,10 L3,5 z" fill="#e74c3c"/>
    </marker>
  </defs>
</svg>
