
begin_frame()
record_commands()
submit_frame()
present_frame()




RendererBegin(cmd, frame_info)
RendererDrawMesh(cmd, mesh, material, transform)
RendererEnd(cmd)



FrameSync sync = sync_system.acquire()
queue.submit(sync, cmd)
sync_system.present(sync)



bool renderer_begin_frame(Renderer*, FrameContext*)
void renderer_end_frame(Renderer*, FrameContext*)
$

Step 1: Extract swapchain handling

Create:

bool renderer_begin_frame(Renderer*, FrameContext*)
void renderer_end_frame(Renderer*, FrameContext*)


Move image acquire, fences, and present inside them.

The loop should shrink



.Step 2: Extract command recording

Create:

VkCommandBuffer renderer_begin_commands(Renderer*, FrameContext*)
void renderer_submit_commands(Renderer*, FrameContext*, VkCommandBuffer)



Move rendering into “record_frame()”

Inside:

void record_frame(Renderer* r, FrameContext* f) {
    begin_rendering(...)
    draw_stuff(...)
    end_rendering(...)
}


Now new rendering features go there instead of main loop cancer.



while (!should_close()) {
    poll_events()

    FrameContext* frame;
    if (!renderer_begin_frame(&renderer, &frame))
        continue

    VkCommandBuffer cmd = renderer_begin_commands(&renderer, frame)

    record_frame(&renderer, frame, cmd)

    renderer_submit_commands(&renderer, frame, cmd)
    renderer_end_frame(&renderer, frame)
}
